ПОСЛЕДНИЕ ИЗМЕНЕНИЯ
-------------------------
СБОРКА.
	В make-файле определены цели client и server для отдельной сборки необходимой части.
По умолчанию сборка осуществляет обе части.

РЕАЛИЗАЦИЯ.
Добавлена поддержка сети.
Я попытался сделать более менее надежную не многопоточную систему.
Поддержка работы с сетью реализована через класс NetworkSubSystem.
Экземпляр этого класса объявлен полем класса Server.
При запуске сервера происходит инициализация файловой подсистемы и
подсистемы сети. Не успешная инициализация считается критической,
серверная программа завершается.

Сетевое взаимодействие серверной части организовано примерно по следующей схеме:

   Ожидание соединения (select) -> Приём данных в буфер  ->  Вызов обработчика
                                                           запроса у класса Server
              ^                                                       |
              |                                                       v
  Закрытие соединения <- Отправка клиенту <- Запись результата <- Обработка
                                              в тот же буфер       запроса

Каждый запрос, присылаемый клиентом, обрабатывается отдельным соединением,
по окончанию обработки запроса, соединение закрывается. Таким образом,
сетевая подсистема не допускает большого количества открытых сокетов в системе,
а также клиент не зависит от сервера и может сосуществовать отдельно, периодически
при необходимости присылая запросы и получая ответы от сервера.

В свою очередь, клиент после успешной авторизации создает feedback канал
(открытое слушающее соединение), для того, чтобы сервер мог присылать информационные
сообщения клиенту. Сервер отправляет сообщения только подключенным (авторизованным)
пользователям. Подсистема сети не работает с feedback соединением, этим занимается
сервер, однако, она предоставляет серверу адрес клиента для установления этого самого
feedback соединения, после того как от клиента приходит запрос в подсистему сети.

При подключении клиента, сокет, созданный для него, включается в список отслеживамых.
При поступлении данных на вновь созданный сокет, сокет добавляется в стек исключаемых
сокетов, подсистема сети размещает данные в буфере обмена, вызывает обработчик запроса
у сервера, сервер обрабатывает запрос, основываясь на данных в буфере и размещает в
этом же буфере ответ. Далее подсистема сети через тот же сокет отправляет данные в
буфере клиенту, содержащие результат обработки запроса сервером, и закрывает соединение.

У клиента вызов основных функций происходит по той же схеме

      Порядок вызова основных функций:
                    entry()
                  /        \
                 /          \
                /            \
               /              \
    authentication ()      registration()
          |
     userSpace()

Однако теперь, клиент создает процесс-потомок перед вызов функции userSpace(),
после успешной авторизации на сервере. Процесс-потомок слушает соединения от сервера,
через это соединение сервер отправляет клиенту сообщения от других пользователей,
уведомления о приватных сообщениях.

          authentication()
        /                  \
       /                    \
      |                      \
    userSpace()             fork();
      |                      /
      |                     /
    disconnect() -> kill ->
      |
    return;

 Если у сервера не получается отправить сообщение клиенту, он исключает клиента из
 списка авторизованных пользователей и последующие попытки клиента связаться с
 серверу потерпят неудачу.

 При выход из учетной записи, процесс потомок уничтожается системным вызовом kill(9),
 зомби-процесс снимается вызовом wait4(...);
 Если в процессе работе, потомок по каким то причинам оказывается снят,
 клиент завершает функцию userSpace(), отправляя disconnect() серверу, и таким
 образом выходит из учетной записи и отправляет уведомление серверу об отключении.

 ЗАПУСК.
 Клиент и сервер по умолчанию собираются в исполняемые файлы chat_server и
 chat_client. При этом, при запуске клиента, можно передать параметры через
 аргументы командной строки:
 -sa для установки адреса сервера, -sp для установки порта сервера и
 -cp для установки порта слушающего соединения у себя.
 По умолчанию клиент настроен на localhost.


------------------------
Добавлена поддержка работы с файлами.
Поддержка работы с файлами реализована через создание класса FileSubsystem в server.h
класс FileSubsystem определен внутри класса Server. Создается по умолчанию экземпляр
класса с одноименным названием (fileSubsystem).

Вначале запуска Server "инициализирует" файловую подсистему через вызов метода init() y
fileSubsystem. Если метод возвращает false (Инициализация не успешна) происходит выброс
исключения, программа аварийно самостоятельно завершается.
Поводом для завершения может быть отсутствие прав на работу с нужными файлами или
директориями.

В свою очередь FileSubsystem либо создает (если нет), либо открывает необходимые файлы для
работы сервера, такие как users, global_messages. Далее в ходе работы, при необходимости
работы с приватными сообщениями пользователей, создает дополнительные соответствующие файлы
для каждого пользователя.

Необходимые файлы для работы определены через #define в заголовке server.h
GLOBAL_MESSAGES_FILE - файл глобальных сообщений сервера
USERS_FILE - файл хранения зарегистрированных пользователей
PERSONAL_MESSAGES_PATH - директория для хранения персональных файлов пользователей с личными
сообщениями.

FileSubsystem никак не влияет на файловые потоки, кроме как связывает их с файлами, создает
директории если необходимо, а так же каждый раз при создании или открытии файла, пытается
выставить права, и в конце концов предоставляет готовые файловые потоки серверу.

В заголове server.h есть определения по загрузке, хранению кол-ва сообщений.
Сервер хранит в памяти кол-во сообщений, загружаемое им из файла, с учетом коэффициента.
При превышении этого значения, освобождается память от старых сообщений.
В дальнейшем клиент может загрузить необходимое кол-во сообщений, и сервер загрузит их
из файла.


-----------------------------

Я пересмотрел архитектуру, разделил на серверную и клиентскую часть, чтобы в дальнейшем
было проще развивать проект.
    Плюс я долго думал над тем, как хранить пользователей на сервере.
    Основной упор был на то, чтобы обращаться к пользователям можно было быстро.
    У пользователей есть два поля. login и nickname.
    Причем серверная часть в основном работает через login, клиентская напротив через nickname.

Хранить в отсортированном виде в последовательном контейнере не получится. Т.к. юзеры хранятся
в отсортированном виде только по одному полю.

Мне изначально пришла в голову идея создать собственное префиксное дерево.
В нем я хранил одновременно и логины и ники, со своими маркерами и указателями на нужный адрес
пользователя.

Как оказалось на практике, такая структура потребляет очень много памяти.
Я генерировал случайные логины и ники, добавляя их в дерево. Примерно после 800 000 добавлений,
память заканчивалась, компьютер зависал. Надо было на калькуляторе посчитать примерно сразу :)

В итоге пришел к идее хранить в двух "std::map" и логины и никнеймы. Памяти нужно в несколько раз
меньше. Доступ быстрый. Юзеры хранятся в куче где попало, без контейнера. Плюс появилась возможность
предоставить пользователям выбирать большее кол-во символов для своих login и nickname. И главное, избавился
от мучений по грамотному написанию собственного ассоциативного контейнера.



-------
В заголовочном файле server.h определено пространство имен requestStructures.
В нем описаны структуры  для запросов от клиента серверу.
Клиент обращается к серверу через перегруженную у функцию request с аргументами в виде структур из
указанного выше пространства имен.


Для идентификации клиента сервером, при аутентификации клиента,
сервером генерируется дескриптор из 20ти символов.
В дальнейшем при отправке запросов на сервер, этот дескриптор передается внутри любого запроса клиентом.

В main создается для примера один сервер и один клиент. Через метод connect() подключаем клиента к серверу.

Далее в зависимости от выбора пользователя - вызываются функции для логина
или регистрации.
В моем решении функции вызываются одна из другой, что позволяет создать
иллюзию текстового меню.
Таким образом например возврат в предыдущее меню осуществляется путем
завершения текущей функции.

      Порядок вызова основных функций:
                   entry()
                 /          \
             /                \
          /                    \
    authentication ()      registration()
       |
     userSpace()

   Функция userSpace() вызывается при успешном логе на сервере.
   У пользователя есть возможность отправлять команды прямо во время ввода.
  Для этого необходимо добавить в начале сообщения символ ':'.
   Пользователь имеет возможность отправлять приватные сообщения другим пользователям,
зарегистрированным на сервере.

       На данный момент список возможных команд следующий:
       :list - отображает пользователей на сервере;
       :user - обращение к пользователю. Пример: ":user another_user";
         Если после имени пользователя нет аргументов, предлагается ввод сообщения
    для отправки ему, иначе все переданные аргументы интерпретируются как сообщение.
       :priv - отображает приватные сообщения;
       :out (эквивалент :q) - выход из учетной записи;
       :exit - выход из программы;
       :help - вывод текущей справки.



Пожалуйста, расскажите о том, как лучше всего делать взаимодействие между клиентом и сервером.
И каким образом сервер должен хранить информацию о пользователях и т.п.
Спасибо!.
